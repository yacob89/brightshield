{"ast":null,"code":"import PropTypes from 'prop-types';\nimport React, { Component } from 'react';\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n/**\n * @class TimerMachine\n */\n\n\nvar TimerMachine = function (_Component) {\n  inherits(TimerMachine, _Component);\n  createClass(TimerMachine, null, [{\n    key: \"msToTime\",\n    value: function msToTime(ms) {\n      var milliseconds = ms % 1000;\n      ms = (ms - milliseconds) / 1000;\n      var seconds = ms % 60;\n      ms = (ms - seconds) / 60;\n      var minutes = ms % 60;\n      var hours = (ms - minutes) / 60;\n      return {\n        h: hours,\n        m: minutes,\n        s: seconds,\n        ms: milliseconds\n      };\n    }\n  }, {\n    key: \"formatTime\",\n    value: function formatTime(time) {\n      var pad = function pad(n) {\n        var z = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n        return (\"00\" + n).slice(-z);\n      };\n\n      return pad(time.h) + \":\" + pad(time.m) + \":\" + pad(time.s) + \".\" + pad(time.ms, 3);\n    }\n  }]);\n\n  function TimerMachine(props) {\n    classCallCheck(this, TimerMachine);\n\n    var _this = possibleConstructorReturn(this, (TimerMachine.__proto__ || Object.getPrototypeOf(TimerMachine)).call(this, props));\n\n    _this.state = {\n      time: TimerMachine.msToTime(props.timeStart),\n      milliseconds: props.timeStart\n    };\n    _this.timer = 0;\n    _this.every = props.interval;\n    _this.internalState = 0; //  0 = idle, 1 = running, 2 = paused, 3 = resumed\n\n    _this.remaining = 0;\n    _this.startTime = 0;\n    _this.startTimer = _this.startTimer.bind(_this);\n    _this.pauseTimer = _this.pauseTimer.bind(_this);\n    _this.resumeTimer = _this.resumeTimer.bind(_this);\n    _this.stopTimer = _this.stopTimer.bind(_this);\n    _this.resetTimer = _this.resetTimer.bind(_this);\n    _this.timeoutCallback = _this.timeoutCallback.bind(_this);\n    _this.tick = _this.tick.bind(_this);\n    return _this;\n  }\n\n  createClass(TimerMachine, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var _props = this.props,\n          timeStart = _props.timeStart,\n          countdown = _props.countdown,\n          started = _props.started,\n          paused = _props.paused,\n          interval = _props.interval;\n      var milliseconds = this.state.milliseconds;\n      this.every = countdown ? -interval : interval;\n\n      if (started) {\n        // start timer if not started already\n        if (this.internalState === 0) {\n          this.resetTimer();\n          this.startTimer();\n        }\n\n        if (paused) {\n          this.pauseTimer();\n        } else {\n          this.resumeTimer();\n        }\n      } else {\n        if (timeStart !== milliseconds) {\n          this.stopTimer();\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.stopTimer();\n    }\n  }, {\n    key: \"startTimer\",\n    value: function startTimer() {\n      var onStart = this.props.onStart;\n      onStart(this.state.time);\n      this.startTime = new Date();\n      this.timer = setInterval(this.tick, this.props.interval);\n      this.internalState = 1;\n    }\n  }, {\n    key: \"stopTimer\",\n    value: function stopTimer() {\n      var onStop = this.props.onStop;\n      onStop(this.state.time);\n\n      if (this.timer) {\n        clearInterval(this.timer);\n      }\n\n      this.timer = 0;\n      this.internalState = 0;\n    }\n  }, {\n    key: \"pauseTimer\",\n    value: function pauseTimer() {\n      if (this.internalState !== 1) return;\n      var _props2 = this.props,\n          interval = _props2.interval,\n          onPause = _props2.onPause;\n      onPause(this.state.time);\n      this.remaining = interval - (new Date() - this.startTime);\n      clearInterval(this.timer);\n      this.internalState = 2;\n    }\n  }, {\n    key: \"resumeTimer\",\n    value: function resumeTimer() {\n      if (this.internalState !== 2) return;\n      var onResume = this.props.onResume;\n      onResume(this.state.time);\n      window.setTimeout(this.timeoutCallback, this.remaining);\n      this.internalState = 3;\n    }\n  }, {\n    key: \"resetTimer\",\n    value: function resetTimer() {\n      var timeStart = this.props.timeStart;\n      this.setState({\n        time: TimerMachine.msToTime(timeStart),\n        milliseconds: timeStart\n      });\n    }\n  }, {\n    key: \"timeoutCallback\",\n    value: function timeoutCallback() {\n      if (this.internalState !== 3) return;\n      this.tick();\n      this.startTime = new Date();\n      this.timer = setInterval(this.tick, this.props.interval);\n      this.internalState = 1;\n    }\n  }, {\n    key: \"tick\",\n    value: function tick() {\n      // Remove interval, set state so a re-render happens.\n      var _props3 = this.props,\n          onComplete = _props3.onComplete,\n          onTick = _props3.onTick,\n          timeEnd = _props3.timeEnd,\n          countdown = _props3.countdown;\n      var milliseconds = this.state.milliseconds;\n      var msRemaining = milliseconds + this.every;\n      var timeRemaining = TimerMachine.msToTime(msRemaining);\n      this.setState({\n        time: timeRemaining,\n        milliseconds: msRemaining\n      });\n      onTick(timeRemaining); // Check if timer completed.\n\n      if (countdown && msRemaining <= timeEnd || !countdown && timeEnd && msRemaining >= timeEnd) {\n        this.stopTimer();\n        onComplete(timeRemaining);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _state = this.state,\n          time = _state.time,\n          milliseconds = _state.milliseconds;\n      var timer = this.props.formatTimer(time, milliseconds);\n      return React.createElement(React.Fragment, null, timer);\n    }\n  }]);\n  return TimerMachine;\n}(Component);\n\nTimerMachine.propTypes = {\n  timeStart: PropTypes.number.isRequired,\n  timeEnd: PropTypes.number,\n  countdown: PropTypes.bool,\n  interval: PropTypes.number,\n  started: PropTypes.bool,\n  paused: PropTypes.bool,\n  formatTimer: PropTypes.func,\n  onTick: PropTypes.func,\n  onStart: PropTypes.func,\n  onPause: PropTypes.func,\n  onResume: PropTypes.func,\n  onStop: PropTypes.func,\n  onComplete: PropTypes.func\n};\nTimerMachine.defaultProps = {\n  timeEnd: 0,\n  countdown: false,\n  interval: 1000,\n  started: false,\n  paused: false,\n  formatTimer: function formatTimer(time, ms) {\n    return TimerMachine.formatTime(time);\n  },\n  onTick: function onTick(time) {},\n  onStart: function onStart(time) {},\n  onPause: function onPause(time) {},\n  onResume: function onResume(time) {},\n  onStop: function onStop(time) {},\n  onComplete: function onComplete(time) {}\n};\nexport default TimerMachine;","map":null,"metadata":{},"sourceType":"module"}